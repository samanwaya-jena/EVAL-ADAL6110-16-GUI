;*********************************************************************************************
; Copyright 2015 ON Semiconductor.  This software and/or documentation is provided by 
; ON Semiconductor under limited terms and conditions.  
; The terms and conditions pertaining to the software and/or documentation are available at 
; www.onsemi.com ("ON Semiconductor Standard Terms and Conditions of Sale, Section 8 Software").  
; Do not use this software and/or documentation unless you have carefully read and you agree 
; to the limited terms and conditions.  
; By using this software and/or documentation, you agree to the limited terms and conditions. 
;*********************************************************************************************

; $Revision: 49228 $
; $Date: 2017-12-04 09:17:45 -0800 (Mon, 04 Dec 2017) $
        
;	Script for AR0132 to read and decode embedded data without skipping frame                             
;                                                                                             
;                                                                                             
; 	The script will first wait for sync up with the beginning of a frame                      
; 	and then modify the targeted registers and continuously grab 6 frames
;	after then. With the grabbed frames it read the embedded data and print           
; 	the changed registers values in each frame, so user is able notice when                       
; 	the registers being changed without skipping frame.
;
;	Note: Script are custome made for AR0132 with Bayer 12 data format.
;	Sensor with different data output format may not work correctly.                        
;                        
; 	Usage :            
; 	1. Load the ini file after sensor is initialized in Devware               
; 	2. Load "Python:Read Embedded" preset.           
;	3. Registers values are displayed in the Python console.
;	4. If user wants to see more registers values, add the address in the addr_list
;	5. If user wants to modify more registers before grab frames, add the registers 
;          values in ghe write_reg() module.	                                                            
;      	6. User need to save and reload the ini file for any modification to take effect.
;                
;                                                                               
;*************************************************************************************/       


[Python:]
addr_list=(0x3002, 0x3006, 0x3012, 0x305E, 0x3070, 0x3071, 0x3072, 0x3073,\
 0x3074, 0x3075, 0x3076, 0x3077, 0x3078, 0x3082, 0x30B0, 0x3100, 0x318C)

def write_reg():
	reg.ae_ctrl_reg.ae_enable =0	#disable AE
	reg.y_addr_start.value += 4
	reg.reg(0x3006).value = 0x03C0
	reg.reg(0x305E).value = 0x0033
	reg.reg(0x3082).value = 0x0002
	reg.reg(0x3070).value = 0x0007
	reg.reg(0x3072).value = 0x0007
	reg.reg(0x3074).value = 0x0007
	reg.reg(0x3076).value = 0x0001
	reg.reg(0x3078).value = 0x0001
	#reg.reg(0x30B0).value = 0x1020
	reg.reg(0x318C).value = 0x0060
	reg.digital_test.col_gain_cb = 2

	
def convert_bytes(b1, b2, b3, b4):
	b_hi= (b2<<4) + (b1>>4)
	b_lo= (b4<<4) + (b3>>4)
	two_b= (b_hi<<8) + b_lo
	return two_b

def print_data(address, data):
	for x in range(len(addr_list)):
		if address==addr_list[x]:
			print('address : 0x{0:04x}'.format(address), '= 0x{0:04x}'.format(data))
				 
	

def get_data(addr, start_i):
	j = start_i	
	

	while (j <16380):
		tag = (img[j+1]<<4) + (img[j]>>4)

		if (tag == 0x5A) or (tag ==0x55):
			tag1 = (img[j+5]<<4) + (img[j+4]>>4)
			if (tag1 != 0x5A) and (tag !=0x55):
				#print('no data/end of data in 1st line')
				break
		
			data = convert_bytes(img[j+2], img[j+3], img[j+6], img[j+7])		
			print_data(addr, data)
			addr += 2
			j += 8
		
		#posible signal a long jump case
		elif (tag==0xAA):
			tag1 = (img[j+5]<<4) + (img[j+4]>>4)			
			if (tag1 == 0xA5):
				addr=convert_bytes(img[j+2], img[j+3], img[j+6], img[j+7])
				j += 8
			else:
				#print('no data/end of data in 2nd line')
				break 
		
		#signal a short jump case	
		elif (tag==0xA5):
			addr_lo = (img[j+3]<<4) + (img[j+2]>>4)
			addr += addr_lo
			j += 4

			

		else:
			#print('no data/end of data in this line')
			break

	return j

[Python:Read Embedded]

#poll frame counter to  write registers at the beginning of the frame
timeout = 0
fr_cnt =  reg.frame_count.uncached_value
while (reg.frame_count.uncached_value == fr_cnt and timeout < 50): 
	apbase.delay(10) 
	timeout += 1
if (timeout != 50):
	write_reg()
	
	#Grab 6 frames
	for i in range(0, 6):
		statuscode, img = apbase.Camera().grab_frame()
		if statuscode!=0:
			pass

		#We know there are 2 rows of data
		for k in range (0,2) :
			
			#first row of data
			if k==0:
				if img[0] != 0xA0: #look for format code
					print('frame',i ,'has no/illegal data, grabbing the next frame')
					print('0x{0:02x}'.format(img[0]))
			
				else: #look for address tags
					tag1 = (img[3]<<4) + (img[2]>>4)
					if 	tag1 != 0xAA:
						print('This frame has no/illegal data, grabbing the next frame')
						continue
					tag2 =  (img[7]<<4) + (img[6]>>4)
					if tag2 != 0xA5:
						print('This frame has no/illegal data, grabbing the next frame')
						continue
			

					#frame count expected at 0x303A	
					frame_c = convert_bytes(img[244],img[245],img[248],img[249])
					print('\nframe count : 0x{0:04x}'.format(frame_c))

					addr=convert_bytes(img[4], img[5], img[8], img[9])
					start_index =10
					b_index = get_data(addr, start_index)
					#print(b_index)

			
			else:  #search for the beginning byte of 2nd row
				found = False
				while(img):
					if img[b_index]== 0xA0:
						found=True
						break
					else:
						b_index +=1

				if found:
					#look for address tags
					tag1 = (img[b_index+3]<<4) + (img[b_index+2]>>4)
					if 	tag1 != 0xAA:
						print(' this frame 2nd row has no/illegal data, grabbing the next frame')	
						continue
											
					tag2 =  (img[b_index+7]<<4) + (img[b_index+6]>>4)
					if tag2 != 0xA5:
						print('This frame 2nd row has no/illegal data, grabbing the next frame')
						continue
			
					

					addr=convert_bytes(img[b_index+4], img[b_index+5], img[b_index+8], img[b_index+9])
					b1_index = get_data(addr, b_index+10)
					#print(b1_index)
						
				
